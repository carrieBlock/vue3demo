{
  "version": 3,
  "sources": ["../src/index.ts", "../src/parse.ts"],
  "sourcesContent": ["export { baseParse } from \"./parse\";\n", "import { NodeTypes } from \"./ast\";\n\nfunction createParseContext(content) {\n  return {\n    line: 1,\n    column: 1,\n    offset: 0,\n    source: content, // \u5C31\u4F1A\u88AB\u4E0D\u505C\u7684\u622A\u53D6\n    originalSource: content, // \u6C38\u8FDC\u4E0D\u4F1A\u53D8\u7684\n  };\n}\n\nfunction getCursor(context) {\n  const { line, column, offset } = context;\n  return { line, column, offset };\n}\n\nfunction isEnd(context) {\n  const s = context.source;\n  if (startsWith(s, \"</\")) return true; // </span>\n  return !s;\n}\n\nfunction startsWith(s, key) {\n  return s.startsWith(key);\n}\n\nfunction pushNode(nodes, node) {\n  nodes.push(node);\n}\n\nfunction advanceBy(context, length) {\n  const source = context.source;\n  advancePositionWithMutation(context, source, length);\n  context.source = source.slice(length);\n}\n\nfunction advanceSpaces(context) {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\n  if (match) {\n    advanceBy(context, match[0].length);\n  }\n}\n\nfunction advancePositionWithMutation(context, source, length) {\n  let linesCount = 0;\n  let lastNewPos = -1;\n  for (let i = 0; i < length; i++) {\n    if (source.charCodeAt(i) === 10) {\n      // \u6362\u884C\u7B26\n      linesCount++;\n      lastNewPos = i;\n    }\n  }\n\n  context.line += linesCount; // abcccc\n  context.offset += length;\n  /**\n   * column:\n   *  a\n   *  b\n   *    cccc\n   *\n   */\n  context.column =\n    lastNewPos === -1 ? context.column + length : length - lastNewPos;\n}\n\nfunction getSelection(context, start, end?) {\n  end = end || getCursor(context);\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset),\n  };\n}\n\nexport function baseParse(content) {\n  const context = createParseContext(content); // \u521B\u5EFA\u597D\u4E86\u4E00\u4E2A\u4E0A\u4E0B\u6587\n  return parseChildren(context);\n}\n\nfunction parseChildren(context) {\n  // node\n  const nodes = [];\n  // context === '' context.startsWith('</')\n  while (!isEnd(context)) {\n    // \u89E3\u6790\n    const s = context.source; // \u7528\u6237\u4F20\u5165\u7684\u5B57\u7B26\u4E32\n    let node;\n    if (startsWith(s, \"{{\")) {\n      // {{ <\n      // \u89E3\u6790\u63D2\u503C\u8BED\u6CD5\n      // node = parseFn1\n      node = parseInterPolation(context);\n    } else if (s[0] === \"<\" && /[a-z]/i.test(s[1])) {\n      // <d\n      // node = parseFn2\n      node = parseElement(context);\n    }\n\n    if (!node) {\n      // \u5C31\u5F53\u6210\u6587\u672C\u89E3\u6790\n      node = parseText(context);\n    }\n\n    pushNode(nodes, node);\n  }\n  return nodes;\n}\n\nfunction parseElement(context) {\n  const element = parseTag(context, \"START\");\n  if (element.isSelfClosing) {\n    return element;\n  }\n  // <div />\n  // </span></div>\n  const children = parseChildren(context);\n  element.children = children;\n\n  // tag close\n  parseTag(context, \"END\");\n  element.loc = getSelection(context, element.loc.start); //\n  return element;\n}\n\nfunction parseTag(context, type) {\n  const start = getCursor(context);\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\n  const tag = match[1]; // div <div\n  advanceBy(context, match[0].length);\n  advanceSpaces(context); // \u5C1D\u8BD5\u8DF3\u8FC7\u7A7A\u683C\n\n  // \u89E3\u6790props\n  const props = parseAttributes(context);\n  // <div a=1></div>\n  const isSelfClosing = startsWith(context.source, \"/>\");\n  // <div></div>\n  // <div />\n\n  /**\n   *\n   *\n   */\n  advanceBy(context, isSelfClosing ? 2 : 1);\n\n  if (type === \"END\") return;\n\n  return {\n    type: NodeTypes.ELEMENT,\n    children: [],\n    isSelfClosing,\n    tag,\n    props,\n    loc: getSelection(context, start),\n  };\n}\n\nfunction parseAttributes(context) {\n  const props = []; // <div></div> <div />\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, \">\") &&\n    !startsWith(context.source, \"/>\")\n  ) {\n    const attr = parseAttribute(context);\n    // <div a=1 b=2></div>\n    if (attr && attr.name === \"class\" && attr.value.value) {\n      // class value trim\n      //  a b c\n      attr.value.value = attr.value.value.replace(/\\s+/g, \" \").trim();\n    }\n\n    props.push(attr);\n    advanceSpaces(context);\n  }\n  return props;\n}\n\nfunction parseAttribute(context) {\n  const start = getCursor(context);\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n  let name = match[0];\n  advanceBy(context, name.length);\n  let value;\n  //  1></div> // 1 '1' \"1\"\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context);\n    advanceBy(context, 1);\n    advanceSpaces(context);\n    value = parseAttributeValue(context);\n  }\n\n  if (/^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n    // v-if if v-model model @click\n    const match =\n      /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\n        name\n      );\n    const dirName =\n      match[1] ||\n      (startsWith(match[0], \":\")\n        ? \"bind\"\n        : startsWith(match[0], \"@\")\n        ? \"on\"\n        : \"slot\");\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name: dirName,\n      exp: value,\n      loc: getSelection(context, start),\n    };\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value,\n    loc: getSelection(context, start),\n  };\n}\n\nfunction parseAttributeValue(context) {\n  const start = getCursor(context);\n  const quote = context.source[0];\n  const isQuote = quote === '\"' || quote === \"'\";\n  let value;\n  if (isQuote) {\n    advanceBy(context, 1);\n    const index = context.source.indexOf(quote);\n    value = parseTextData(context, index);\n    advanceBy(context, 1);\n  } else {\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\n    value = parseTextData(context, match[0].length);\n  }\n  const loc = getSelection(context, start);\n  return {\n    type: NodeTypes.TEXT,\n    value,\n    loc,\n  };\n}\n\nfunction parseInterPolation(context) {\n  // {{abc}} type\n  const start = getCursor(context);\n  const open = \"{{\";\n  const close = \"}}\";\n\n  const endIndex = context.source.indexOf(close, open.length);\n  advanceBy(context, open.length); // \u5220\u6389 {{\n  const innerStart = getCursor(context);\n  const rawContentLength = endIndex - open.length;\n  const content = parseTextData(context, rawContentLength);\n  const innerEnd = getCursor(context);\n  advanceBy(context, close.length); // \u5220\u9664 }}\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION, // \u7B80\u5355\u8868\u8FBE\u5F0F\n      content, // abc\n      loc: getSelection(context, innerStart, innerEnd), //\n    },\n    loc: getSelection(context, start),\n  };\n}\n\nfunction parseText(context) {\n  // 'abc123 {{e}}<div></div> abc123'\n  const endTokens = [\"<\", \"{{\"];\n  const start = getCursor(context);\n  let endIndex = context.source.length;\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1);\n    if (index !== -1 && endIndex > index) {\n      endIndex = index;\n    }\n  }\n  const content = parseTextData(context, endIndex);\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start),\n  };\n}\n\nfunction parseTextData(context, length) {\n  const rawText = context.source.slice(0, length);\n  advanceBy(context, length);\n  return rawText;\n}\n"],
  "mappings": "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",
  "names": ["match"]
}
